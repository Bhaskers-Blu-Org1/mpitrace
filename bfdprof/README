This directory has utilities to analyze program sampling data :

    bfdprof your.exe  hpm_histogram.jobid.rank  >source_profile.txt
    provides statement-level annotation and function-level summaries

    annotate_objdump your.exe  hpm_histogram.jobid.rank >asm_profile.txt
    provides annotation at the assembly level : hits per instruction address

Your executable file should be built with options that include "-g" so the
tools can translate from instruction address to source file and line number.

Both tools work with program-sampling histograms produced by either of two
mechanisms : (1) hardware-counter interrupts generated via libhpmprof.so,
or (2) interrupts generated by the profil() routine, which can be enabled
with libmpitrace.so when it is built with the -DVPROF option.  The hardware
counter method is preferred, in which case the profiler outputs have names :
hpm_histogram.jobid.rank.  The interrupt handler for the hardware counter
method has more capability, for example it can collect data on shared 
libraries.  The profil() mechanism produces files with names : 
vmon.out.jobid.rank.  Analysis is the same, using vmon.out.jobid.rank in 
place of hpm_histogram.jobid.rank in the examples above.  The profil() routine
uses unsigned short integers to hold the profile data, and so there can be
buffer overflow if the number of hits exceeds 65536 at any instruction address.
The hardware-counter method does not have that limitation.

===============================================================================
Building / Installing 

To build bfdprof, you need GNU binutils development files.  It is recommended
to build these from source at ftp.gnu.org following directions in a section
below.  After ensuring that you have binutils installed, the following steps
should build bfdprof and annotate_objdump :

  (1) ./configure --with-binutils=/path/to/binutils
  (2) edit makefile and ensure that the include and library paths are correct
  (3) make

You can copy or move the bfdprof and annotate_objdump executables to a location
in your PATH.

===============================================================================
Building GNU binutils

  (1) get the latest GNU binutils from ftp.gnu.org
  (2) export CC=gcc;  export CFLAGS="-g -O2 -fPIC"
      export CXX=g++; export CXXFLAGS="-g -O2 -fPIC"
  (3) configure --prefix=/path/to/binutils
  (4) make
  (5) edit libiberty/Makefile; set target_header_dir = ${prefix}/include
  (6) make install
  (7) cp bfd/config.h /path/to/binutils/include

Note that steps (5) and (7) are required to get all components in place.

===============================================================================
Note on interpretation of profile data

The basic program-sampling data is a histogram with the count of profiler hits
at each instruction address.  The "annotate_objdump" utility displays this
information directly.  It is not always easy to associate an instruction 
address with a unique source-file and line number.  The "bfdprof" utility
uses methods from GNU binutils to do this; bfd_find_nearest_line() and 
bfd_find_inliner_info().  Interpretation can be quite challenging particularly
for C++ codes that rely extensively on inlining of functions defined in header
files.  For a list of options try "bfdprof -h".  By default the tool will 
attempt to unwind inlining, but you can control that for example :

     bfdprof -i 0  your.exe  hpm_histogram.jobid.rank >source_profile.txt

will disable unwinding of inlined functions.  Also, a processor typically
has many instructions in flight, possibly from multiple source lines, and
so there is always some uncertainty when it comes to interpreting profiler
outputs.  It is recommended to profile for a time that is sufficient to 
collect enough samples to provide a useful snapshot of performance.  One
should not expect perfect line-by-line association of the profiler hits, 
but the source-level view is frequently quite useful in any case.

